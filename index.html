<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced 3D Solar System</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #controls {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.5); padding: 10px;
      color: white; border-radius: 5px;
    }
    button, select {
      margin: 5px; padding: 10px; font-size: 14px;
      cursor: pointer; border-radius: 5px;
      background-color: #333; color: white; border: none;
    }
    button:hover, select:hover { background-color: #555; }
  </style>
</head>
<body>
  <div id="controls">
    <button id="changeCamera">Change Camera</button>
    <br>
    <label for="speedControl">Orbit Speed:</label>
    <select id="speedControl">
      <option value="1">1x (Default)</option>
      <option value="0.5">0.5x</option>
      <option value="0.25">0.25x</option>
      <option value="0.1">0.1x</option>
      <option value="real">Real-time</option>
    </select>
  </div>

  <audio id="backgroundMusic" loop autoplay muted>
    <source src="music1.mp3" type="audio/mpeg">
  </audio>

<script>
  const music = document.getElementById("backgroundMusic");
  window.addEventListener("click", () => {
    music.muted = false;
    music.play();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.153.0/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script>
  // Scene setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Background stars
  const starGeometry = new THREE.BufferGeometry();
  const starMaterial = new THREE.PointsMaterial({ color: 0xffffff });
  const starVertices = [];
  for (let i = 0; i < 5000; i++) {
    starVertices.push((Math.random() - 0.5) * 2000);
    starVertices.push((Math.random() - 0.5) * 2000);
    starVertices.push((Math.random() - 0.5) * 2000);
  }
  starGeometry.setAttribute("position", new THREE.Float32BufferAttribute(starVertices, 3));
  scene.add(new THREE.Points(starGeometry, starMaterial));

  // Sun
  const sun = new THREE.Mesh(new THREE.SphereGeometry(5,32,32),
                             new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
  scene.add(sun);
  scene.add(new THREE.PointLight(0xffcc00, 3, 500));

  // Planets
  const planets = [
    { name: "Mercury", size: 0.5, orbitRadius: 10, speed: 0.02, color: 0xaaaaaa, period: 88 },
    { name: "Venus",   size: 1,   orbitRadius: 15, speed: 0.015, color: 0xffaa00, period: 225 },
    { name: "Earth",   size: 1.2, orbitRadius: 20, speed: 0.01, color: 0x00aaff, period: 365 },
    { name: "Mars",    size: 0.9, orbitRadius: 25, speed: 0.008, color: 0xff4500, period: 687 },
    { name: "Jupiter", size: 3,   orbitRadius: 35, speed: 0.005, color: 0xffaa33, period: 4333 },
    { name: "Saturn",  size: 2.5, orbitRadius: 45, speed: 0.004, color: 0xffcc99, period: 10759 },
  ];

  const planetMeshes = planets.map(p => {
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(p.size,32,32),
      new THREE.MeshStandardMaterial({ color: p.color })
    );
    scene.add(mesh);
    return { ...p, mesh, angle: Math.random()*Math.PI*2 };
  });

  // Moon
  const moon = new THREE.Mesh(
    new THREE.SphereGeometry(0.3,32,32),
    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
  );
  scene.add(moon);

  // Shooting stars
  function createShootingStar(){
    const star = new THREE.Mesh(
      new THREE.SphereGeometry(0.1,16,16),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    star.position.set((Math.random()-0.5)*200, Math.random()*50, (Math.random()-0.5)*200);
    scene.add(star);
    gsap.to(star.position,{x:"+=50",y:"-=50",z:"+=50",duration:1.5,onComplete:()=>scene.remove(star)});
  }
  setInterval(createShootingStar, 800);

  // Camera control
  let camIndex = 0;
  const cameraPositions = [
    {x:0,y:50,z:100},
    {x:0,y:100,z:0},
    {x:100,y:20,z:0}
  ];
  function switchCamera(){
    camIndex = (camIndex+1)%cameraPositions.length;
    const pos = cameraPositions[camIndex];
    camera.position.set(pos.x,pos.y,pos.z);
    camera.lookAt(0,0,0);
  }
  document.getElementById("changeCamera").addEventListener("click", switchCamera);

  // Speed control
  let speedMode = 1;
  document.getElementById("speedControl").addEventListener("change",(e)=>{
    speedMode = e.target.value === "real" ? "real" : parseFloat(e.target.value);
  });

  // Helper â†’ calculate angle from today's date
  function getRealTimeAngle(periodDays){
    const now = new Date();
    const startOfYear = new Date(now.getFullYear(),0,1);
    const dayOfYear = Math.floor((now - startOfYear)/(1000*60*60*24));
    return (dayOfYear/periodDays) * 2*Math.PI;
  }

  // Animate
  function animate(){
    requestAnimationFrame(animate);

    planetMeshes.forEach(p=>{
      if(speedMode==="real"){
        p.angle = getRealTimeAngle(p.period);
      } else {
        p.angle += p.speed*speedMode;
      }
      p.mesh.position.x = p.orbitRadius*Math.cos(p.angle);
      p.mesh.position.z = p.orbitRadius*Math.sin(p.angle);
    });

    // Moon around Earth
    const earth = planetMeshes.find(p=>p.name==="Earth").mesh;
    const moonAngle = Date.now()*0.001;
    moon.position.x = earth.position.x + 2*Math.cos(moonAngle);
    moon.position.z = earth.position.z + 2*Math.sin(moonAngle);

    renderer.render(scene,camera);
  }
  animate();

  // Resize
  window.addEventListener("resize",()=>{
    renderer.setSize(window.innerWidth,window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
